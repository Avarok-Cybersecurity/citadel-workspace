use crate::handlers::domain::DomainOperations;
use crate::handlers::domain::server_ops::DomainServerOperations;
use crate::handlers::domain::DomainEntity;
use crate::kernel::transaction::Transaction;
use citadel_sdk::prelude::{NetworkError, Ratchet};
use citadel_workspace_types::structs::{Domain, User, UserRole};

impl<R: Ratchet + Send + Sync + 'static> DomainOperations<R> for DomainServerOperations<R> {
    fn init(&self) -> Result<(), NetworkError> {
        Ok(())
    }

    fn is_admin(&self, tx: &dyn Transaction, user_id: &str) -> Result<bool, NetworkError> {
        let _user = tx.get_user(user_id).ok_or_else(|| {
            NetworkError::msg(format!("User '{}' not found in is_admin", user_id))
        })?;
        Ok(_user.role == UserRole::Admin)
    }

    fn get_user(&self, user_id: &str) -> Option<User> {
        self.tx_manager
            .with_read_transaction(|tx| Ok(tx.get_user(user_id).cloned()))
            .unwrap_or(None)
    }

    fn with_read_transaction<F, T>(&self, f: F) -> Result<T, NetworkError>
    where
        F: FnOnce(&dyn Transaction) -> Result<T, NetworkError>,
    {
        self.tx_manager.with_read_transaction(f)
    }

    fn with_write_transaction<F, T>(&self, f: F) -> Result<T, NetworkError>
    where
        F: FnOnce(&mut dyn Transaction) -> Result<T, NetworkError>,
    {
        self.tx_manager.with_write_transaction(f)
    }

    fn check_entity_permission(
        &self,
        tx: &dyn Transaction,
        actor_user_id: &str,
        entity_id: &str,
        permission: super::Permission,
    ) -> Result<bool, NetworkError> {
        let actor = tx.get_user(actor_user_id).ok_or_else(|| {
            NetworkError::msg(format!(
                "User '{}' not found in check_entity_permission",
                actor_user_id
            ))
        })?;

        // Admin has all permissions
        if actor.role == UserRole::Admin {
            return Ok(true);
        }

        // Check if user has explicit permission for this entity
        // First check if user exists
        if tx.get_user(actor_user_id).is_none() {
            return Ok(false);
        }
        
        // Then check if the domain exists
        if tx.get_domain(entity_id).is_none() {
            return Ok(false);
        }
        
        // Check user's permissions for this domain
        let user_permissions = tx.get_permissions(actor_user_id)?
            .into_iter()
            .filter(|p| p == &permission)
            .collect::<Vec<_>>();
            
        // If user has the specific permission, return true
        if !user_permissions.is_empty() {
            return Ok(true);
        }
        
        // Otherwise check if user is an admin
        if let Some(user) = tx.get_user(actor_user_id) {
            if user.role == super::UserRole::Admin {
                return Ok(true);
            }
        }

        // User doesn't have direct permissions for this entity
        Ok(false)
    }

    fn is_member_of_domain(
        &self,
        tx: &dyn Transaction,
        user_id: &str,
        domain_id: &str,
    ) -> Result<bool, NetworkError> {
        // Simply delegate to check_entity_permission with no specific permission required
        self.check_entity_permission(tx, user_id, domain_id, super::Permission::All)
    }

    fn get_domain(&self, domain_id: &str) -> Option<Domain> {
        self.tx_manager
            .with_read_transaction(|tx| Ok(tx.get_domain(domain_id).cloned()))
            .unwrap_or(None)
    }

    // Generic domain entity operations: these functions serve as the base for specialized entity operations
    fn get_domain_entity<T: DomainEntity>(&self, user_id: &str, entity_id: &str) -> Result<T, NetworkError> {
        self.tx_manager.with_read_transaction(|tx| {
            // Check if user has permission to access this entity
            if !self.check_entity_permission(tx, user_id, entity_id, super::Permission::All)? {
                return Err(NetworkError::msg(format!(
                    "User '{}' does not have permission to access {}",
                    user_id, entity_id
                )));
            }

            // Get the entity
            // Using get_domain for domain entities
            let domain = tx.get_domain(entity_id).ok_or_else(|| {
                NetworkError::msg(format!(
                    "Entity '{}' of type {} not found",
                    entity_id,
                    std::any::type_name::<T>()
                ))
            })?;
            
            // Convert domain to the requested type
            let entity = T::from_domain(&domain).ok_or_else(|| {
                NetworkError::msg(format!(
                    "Entity '{}' is not of type {}",
                    entity_id,
                    std::any::type_name::<T>()
                ))
            })?;

            Ok(entity.clone())
        })
    }
    
    fn add_user_to_domain(
        &self,
        admin_id: &str,
        user_id_to_add: &str,
        domain_id: &str,
        role: UserRole,
    ) -> Result<(), NetworkError> {
        self.tx_manager.with_write_transaction(|tx| {
            // Check if admin has permission to add users
            if !self.check_entity_permission(tx, admin_id, domain_id, super::Permission::UpdatePermissions)? {
                return Err(NetworkError::msg(format!(
                    "User '{}' does not have permission to add users to domain '{}'",
                    admin_id, domain_id
                )));
            }
            
            // Check if user exists
            let user = tx.get_user(user_id_to_add).ok_or_else(|| {
                NetworkError::msg(format!("User '{}' not found", user_id_to_add))
            })?;
            
            // Check if domain exists
            let domain = tx.get_domain(domain_id).ok_or_else(|| {
                NetworkError::msg(format!("Domain '{}' not found", domain_id))
            })?;
            
            // Add user to domain with specified role
            tx.add_user_to_domain(user_id_to_add, domain_id, role)?;
            Ok(())
        })
    }
    
    fn remove_user_from_domain(
        &self,
        admin_id: &str,
        user_id_to_remove: &str,
        domain_id: &str,
    ) -> Result<(), NetworkError> {
        self.tx_manager.with_write_transaction(|tx| {
            // Check if admin has permission to remove users
            if !self.check_entity_permission(tx, admin_id, domain_id, super::Permission::UpdatePermissions)? {
                return Err(NetworkError::msg(format!(
                    "User '{}' does not have permission to remove users from domain '{}'",
                    admin_id, domain_id
                )));
            }
            
            // Prevent removing the domain owner
            if let Some(domain) = tx.get_domain(domain_id) {
                if domain.owner_id() == user_id_to_remove {
                    return Err(NetworkError::msg(
                        "Cannot remove domain owner from domain"
                    ));
                }
            } else {
                return Err(NetworkError::msg(format!("Domain '{}' not found", domain_id)));
            }
            
            // Remove user from domain
            tx.remove_user_from_domain(user_id_to_remove, domain_id)?;
            Ok(())
        })
    }
    
    fn update_workspace_member_role(
        &self,
        actor_user_id: &str,
        target_user_id: &str,
        role: UserRole,
        metadata: Option<Vec<u8>>,
    ) -> Result<(), NetworkError> {
        self.tx_manager.with_write_transaction(|tx| {
            // Only admins can update roles
            if !self.is_admin(tx, actor_user_id)? {
                return Err(NetworkError::msg(format!(
                    "User '{}' does not have permission to update roles",
                    actor_user_id
                )));
            }
            
            // Check if target user exists
            let target_user = tx.get_user(target_user_id).ok_or_else(|| {
                NetworkError::msg(format!("User '{}' not found", target_user_id))
            })?;
            
            // Cannot change role of workspace admin unless you're also an admin
            if target_user.role == UserRole::Admin && role != UserRole::Admin {
                let actor_is_admin = if let Some(actor) = tx.get_user(actor_user_id) {
                    actor.role == UserRole::Admin
                } else {
                    false
                };
                
                if !actor_is_admin {
                    return Err(NetworkError::msg("Cannot demote an admin unless you are also an admin"));
                }
            }
            
            // Update the user's role
            // Get the user and update their role
            if let Some(mut user) = tx.get_user_mut(target_user_id) {
                // Set permissions based on the new role
                user.clear_permissions(domain_id);
                let permissions = super::Permission::for_role(&role);
                for permission in permissions {
                    user.add_permission(domain_id, permission);
                }
                // Update the user
                tx.update_user(target_user_id, user.clone())?;
                Ok(())
            } else {
                Err(NetworkError::msg(format!("User '{}' not found", target_user_id)))
            }
        })
    }
    
    fn update_member_permissions(
        &self,
        actor_user_id: &str,
        target_user_id: &str,
        domain_id: &str,
        permissions: Vec<Permission>,
        operation: UpdateOperation,
    ) -> Result<(), NetworkError> {
        self.tx_manager.with_write_transaction(|tx| {
            // Check if actor has permission to manage users
            if !self.check_entity_permission(tx, actor_user_id, domain_id, super::Permission::AddUsers)? {
                return Err(NetworkError::msg(format!(
                    "User '{}' does not have permission to update permissions in domain '{}'",
                    actor_user_id, domain_id
                )));
            }
            
            // Check if target user exists
            if tx.get_user(target_user_id).is_none() {
                return Err(NetworkError::msg(format!("User '{}' not found", target_user_id)));
            }
            
            // Check if domain exists
            if tx.get_domain(domain_id).is_none() {
                return Err(NetworkError::msg(format!("Domain '{}' not found", domain_id)));
            }
            
            // Update permissions based on operation
            match operation {
                UpdateOperation::Add => {
                    // Add permissions
                    for permission in permissions {
                        // Get the user and add the permission
                        if let Some(mut user) = tx.get_user_mut(target_user_id) {
                            user.add_permission(domain_id, permission);
                            tx.update_user(target_user_id, user.clone())?;
                        } else {
                            return Err(NetworkError::msg(format!("User '{}' not found", target_user_id)));
                        }
                    }
                },
                UpdateOperation::Remove => {
                    // Remove permissions
                    for permission in permissions {
                        // Get the user and remove the permission
                        if let Some(mut user) = tx.get_user_mut(target_user_id) {
                            user.revoke_permission(domain_id, permission);
                            tx.update_user(target_user_id, user.clone())?;
                        } else {
                            return Err(NetworkError::msg(format!("User '{}' not found", target_user_id)));
                        }
                    }
                },
                UpdateOperation::Set => {
                    // Clear existing permissions and set new ones
                    // Get the user and clear permissions
                    if let Some(mut user) = tx.get_user_mut(target_user_id) {
                        user.clear_permissions(domain_id);
                        tx.update_user(target_user_id, user.clone())?;
                    } else {
                        return Err(NetworkError::msg(format!("User '{}' not found", target_user_id)));
                    }
                    for permission in permissions {
                        // Get the user and add the permission
                        if let Some(mut user) = tx.get_user_mut(target_user_id) {
                            user.add_permission(domain_id, permission);
                            tx.update_user(target_user_id, user.clone())?;
                        } else {
                            return Err(NetworkError::msg(format!("User '{}' not found", target_user_id)));
                        }
                    }
                },
            }
            
            Ok(())
        })
    }
    
    fn create_domain_entity<T: DomainEntity + 'static + serde::de::DeserializeOwned>(
        &self,
        user_id: &str,
        parent_id: Option<&str>,
        name: &str,
        description: &str,
        mdx_content: Option<&str>,
        workspace_master_password: String,
    ) -> Result<T, NetworkError> {
        self.tx_manager.with_write_transaction(|tx| {
            // Check if user exists
            if tx.get_user(user_id).is_none() {
                return Err(NetworkError::msg(format!("User '{}' not found", user_id)));
            }
            
            // If parent ID is provided, check if parent exists and user has permission
            if let Some(parent) = parent_id {
                // Check if parent exists
                if tx.get_domain(parent).is_none() {
                    return Err(NetworkError::msg(format!("Parent domain '{}' not found", parent)));
                }
                
                // Check if user has permission to create entities in parent
                if !self.check_entity_permission(tx, user_id, parent, super::Permission::CreateRoom)? {
                    return Err(NetworkError::msg(format!(
                        "User '{}' does not have permission to create content in domain '{}'",
                        user_id, parent
                    )));
                }
            }
            
            // Generate a unique ID for the new entity
            let entity_id = uuid::Uuid::new_v4().to_string();
            
            // Create the domain entity
            let entity = T::create(entity_id.clone(), parent_id.map(|s| s.to_string()), name, description);
            
            // Convert entity to domain and save it
            let domain = entity.clone().into_domain();
            tx.add_domain(domain)?;
            
            // If MDX content is provided, save it
            if let Some(content) = mdx_content {
                tx.set_mdx_content(&entity_id, content)?;
            }
            
            Ok(entity)
        })
    }
    
    fn delete_domain_entity<T: DomainEntity + 'static>(
        &self,
        user_id: &str,
        entity_id: &str,
    ) -> Result<T, NetworkError> {
        self.tx_manager.with_write_transaction(|tx| {
            // First check if entity exists and get it
            let domain = tx.get_domain(entity_id).ok_or_else(|| {
                NetworkError::msg(format!("Entity '{}' not found", entity_id))
            })?;
            
            // Convert to the requested type
            let entity = T::from_domain(domain.clone()).ok_or_else(|| {
                NetworkError::msg(format!(
                    "Entity '{}' is not of type {}",
                    entity_id,
                    std::any::type_name::<T>()
                ))
            })?;
            
            // Check if user has permission to delete
            if !self.check_entity_permission(tx, user_id, entity_id, super::Permission::DeleteRoom)? {
                return Err(NetworkError::msg(format!(
                    "User '{}' does not have permission to delete domain '{}'",
                    user_id, entity_id
                )));
            }
            
            // Delete the domain entity
            tx.remove_domain(entity_id)?;
                return Err(NetworkError::msg(format!(
                    "Cannot remove owner from workspace '{}'",
                    workspace_id
                )));
            }
            
            // Check if user has permission to remove users from workspace (admin permission)
            if !self.check_entity_permission(tx, user_id, workspace_id, super::Permission::AddUsers)? {
                return Err(NetworkError::msg(format!(
                    "User '{}' does not have permission to remove users from workspace '{}'",
                    user_id, workspace_id
                )));
            }
            
            // Remove user from workspace
            tx.remove_user_from_domain(target_user_id, workspace_id)?;
            
            Ok(())
        })
    }
    
    fn load_workspace(
        &self,
        user_id: &str,
        workspace_id: &str,
    ) -> Result<WorkspaceDetails, NetworkError> {
        // Use the get_workspace_details method to load the workspace
        self.get_workspace_details(user_id, workspace_id)
    }
    
    fn list_workspaces(&self, user_id: &str) -> Result<Vec<Workspace>, NetworkError> {
        self.tx_manager.with_read_transaction(|tx| {
            // Check if user exists
            if tx.get_user(user_id).is_none() {
                return Err(NetworkError::msg(format!("User '{}' not found", user_id)));
            }
            
            // List all workspaces the user has access to
            let all_domains = tx.get_all_domains();
            let mut workspaces = Vec::new();
            
            for domain in all_domains {
                if let Domain::Workspace { workspace } = domain {
                    // Check if user has permission to view this workspace
                    if self.check_entity_permission(tx, user_id, &workspace.id, super::Permission::All)? {
                        workspaces.push(workspace.clone());
                    }
                }
            }
            
            Ok(workspaces)
        })
    }
    
    fn get_all_workspace_ids(&self) -> Result<WorkspaceDBList, NetworkError> {
        self.tx_manager.with_read_transaction(|tx| {
            let all_domains = tx.get_all_domains();
            let mut workspace_ids = Vec::new();
            
            for domain in all_domains {
                if let Domain::Workspace { workspace } = domain {
                    workspace_ids.push(workspace.id.clone());
                }
            }
            
            let list = WorkspaceDBList {
                workspaces: workspace_ids,
            };
            Ok(list)
        })
    }
    
    fn list_offices_in_workspace(
        &self, 
        user_id: &str, 
        workspace_id: &str
    ) -> Result<Vec<Office>, NetworkError> {
        self.tx_manager.with_read_transaction(|tx| {
            // Check if user exists
            if tx.get_user(user_id).is_none() {
                return Err(NetworkError::msg(format!("User '{}' not found", user_id)));
            }
            
            // Check if workspace exists
            let workspace_domain = tx.get_domain(workspace_id).ok_or_else(|| {
                NetworkError::msg(format!("Workspace '{}' not found", workspace_id))
            })?;
            
            // Check if it's a workspace
            if let Domain::Workspace { workspace: _ } = workspace_domain {
                // Continue
            } else {
                return Err(NetworkError::msg(format!("Entity '{}' is not a workspace", workspace_id)));
            }
            
            // Check if user has permission to view workspace
            if !self.check_entity_permission(tx, user_id, workspace_id, super::Permission::All)? {
                return Err(NetworkError::msg(format!(
                    "User '{}' does not have permission to view workspace '{}'",
                    user_id, workspace_id
                )));
            }
            
            // Get all offices in this workspace
            let offices = tx.list_offices_in_workspace(workspace_id)?;
            
            Ok(offices)
        })
    }
}
